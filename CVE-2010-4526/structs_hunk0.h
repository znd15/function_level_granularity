
struct sctp_transport {
	/* A list of transports. */
	struct list_head transports;

	/* Reference counting. */
	atomic_t refcnt;
	int	 dead;

	/* This is the peer's IP address and port. */
	union sctp_addr ipaddr;

	/* These are the functions we call to handle LLP stuff. */
	struct sctp_af *af_specific;

	/* Which association do we belong to? */
	struct sctp_association *asoc;

	/* RFC2960
 *
 * 12.3 Per Transport Address Data
 *
 * For each destination transport address in the peer's
 * address list derived from the INIT or INIT ACK chunk, a
 * number of data elements needs to be maintained including:
 */
	/* RTO : The current retransmission timeout value. */
	unsigned long rto;

	__u32 rtt;		/* This is the most recent RTT. */

	/* RTTVAR : The current RTT variation. */
	__u32 rttvar;

	/* SRTT : The current smoothed round trip time. */
	__u32 srtt;

	/* RTO-Pending : A flag used to track if one of the DATA
 * chunks sent to this address is currently being
 * used to compute a RTT. If this flag is 0,
 * the next DATA chunk sent to this destination
 * should be used to compute a RTT and this flag
 * should be set. Every time the RTT
 * calculation completes (i.e. the DATA chunk
 * is SACK'd) clear this flag.
 * hb_sent : a flag that signals that we have a pending heartbeat.
 */
	__u8 rto_pending;
	__u8 hb_sent;

	/* Flag to track the current fast recovery state */
	__u8 fast_recovery;

	/*
 * These are the congestion stats.
 */
	/* cwnd : The current congestion window. */
	__u32 cwnd;		  /* This is the actual cwnd. */

	/* ssthresh : The current slow start threshold value. */
	__u32 ssthresh;

	/* partial : The tracking method for increase of cwnd when in
 * bytes acked : congestion avoidance mode (see Section 6.2.2)
 */
	__u32 partial_bytes_acked;

	/* Data that has been sent, but not acknowledged. */
	__u32 flight_size;

	__u32 burst_limited;	/* Holds old cwnd when max.burst is applied */

	/* TSN marking the fast recovery exit point */
	__u32 fast_recovery_exit;

	/* Destination */
	struct dst_entry *dst;
	/* Source address. */
	union sctp_addr saddr;

	/* Heartbeat interval: The endpoint sends out a Heartbeat chunk to
 * the destination address every heartbeat interval.
 */
	unsigned long hbinterval;

	/* SACK delay timeout */
	unsigned long sackdelay;
	__u32 sackfreq;

	/* When was the last time (in jiffies) that we heard from this
 * transport? We use this to pick new active and retran paths.
 */
	unsigned long last_time_heard;

	/* Last time(in jiffies) when cwnd is reduced due to the congestion
 * indication based on ECNE chunk.
 */
	unsigned long last_time_ecne_reduced;

	/* This is the max_retrans value for the transport and will
 * be initialized from the assocs value. This can be changed
 * using SCTP_SET_PEER_ADDR_PARAMS socket option.
 */
	__u16 pathmaxrxt;

	/* is the Path MTU update pending on this tranport */
	__u8 pmtu_pending;

	/* PMTU : The current known path MTU. */
	__u32 pathmtu;

	/* Flags controlling Heartbeat, SACK delay, and Path MTU Discovery. */
	__u32 param_flags;

	/* The number of times INIT has been sent on this transport. */
	int init_sent_count;

	/* state : The current state of this destination,
 * : i.e. SCTP_ACTIVE, SCTP_INACTIVE, SCTP_UNKNOWN.
 */
	int state;

	/* These are the error stats for this destination. */

	/* Error count : The current error count for this destination. */
	unsigned short error_count;

	/* Per : A timer used by each destination.
 * Destination :
 * Timer :
 *
 * [Everywhere else in the text this is called T3-rtx. -ed]
 */
	struct timer_list T3_rtx_timer;

	/* Heartbeat timer is per destination. */
	struct timer_list hb_timer;

	/* Since we're using per-destination retransmission timers
 * (see above), we're also using per-destination "transmitted"
 * queues. This probably ought to be a private struct
 * accessible only within the outqueue, but it's not, yet.
 */
	struct list_head transmitted;

	/* We build bundle-able packets for this transport here. */
	struct sctp_packet packet;

	/* This is the list of transports that have chunks to send. */
	struct list_head send_ready;

	int malloced; /* Is this structure kfree()able? */

	/* State information saved for SFR_CACC algorithm. The key
 * idea in SFR_CACC is to maintain state at the sender on a
 * per-destination basis when a changeover happens.
 * char changeover_active;
 * char cycling_changeover;
 * __u32 next_tsn_at_change;
 * char cacc_saw_newack;
 */
	struct {
		/* An unsigned integer, which stores the next TSN to be
 * used by the sender, at the moment of changeover.
 */
		__u32 next_tsn_at_change;

		/* A flag which indicates the occurrence of a changeover */
		char changeover_active;

		/* A flag which indicates whether the change of primary is
 * the first switch to this destination address during an
 * active switch.
 */
		char cycling_changeover;

		/* A temporary flag, which is used during the processing of
 * a SACK to estimate the causative TSN(s)'s group.
 */
		char cacc_saw_newack;
	} cacc;

	/* 64-bit random number sent with heartbeat. */
	__u64 hb_nonce;
}