
sleep_again:
	current->state = TASK_INTERRUPTIBLE;
	sem_unlock(sma);

	if (timeout)
		jiffies_left = schedule_timeout(jiffies_left);
	else
		schedule();

	error = get_queue_result(&queue);

	if (error != -EINTR) {
		/* fast path: update_queue already obtained all requested
 * resources.
 * Perform a smp_mb(): User space could assume that semop()
 * is a memory barrier: Without the mb(), the cpu could
 * speculatively read in user space stale data that was
 * overwritten by the previous owner of the semaphore.
 */
		smp_mb();

		goto out_free;
	}