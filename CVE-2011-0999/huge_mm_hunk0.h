
extern pmd_t *page_check_address_pmd(struct page *page,
				     struct mm_struct *mm,
				     unsigned long address,
				     enum page_check_address_pmd_flag flag);

#ifdef CONFIG_TRANSPARENT_HUGEPAGE
#define HPAGE_PMD_SHIFT HPAGE_SHIFT
#define HPAGE_PMD_MASK HPAGE_MASK
#define HPAGE_PMD_SIZE HPAGE_SIZE

#define transparent_hugepage_enabled(__vma) \
 ((transparent_hugepage_flags & \
 (1<<TRANSPARENT_HUGEPAGE_FLAG) || \
 (transparent_hugepage_flags & \
 (1<<TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG) && \
 ((__vma)->vm_flags & VM_HUGEPAGE))) && \
 !((__vma)->vm_flags & VM_NOHUGEPAGE))
#define transparent_hugepage_defrag(__vma) \
 ((transparent_hugepage_flags & \
 (1<<TRANSPARENT_HUGEPAGE_DEFRAG_FLAG)) || \
 (transparent_hugepage_flags & \
 (1<<TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG) && \
 (__vma)->vm_flags & VM_HUGEPAGE))
#ifdef CONFIG_DEBUG_VM
#define transparent_hugepage_debug_cow() \
 (transparent_hugepage_flags & \
 (1<<TRANSPARENT_HUGEPAGE_DEBUG_COW_FLAG))
#else /* CONFIG_DEBUG_VM */
#define transparent_hugepage_debug_cow() 0
#endif /* CONFIG_DEBUG_VM */

extern unsigned long transparent_hugepage_flags;
extern int copy_pte_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,
			  pmd_t *dst_pmd, pmd_t *src_pmd,
			  struct vm_area_struct *vma,
			  unsigned long addr, unsigned long end);
extern int handle_pte_fault(struct mm_struct *mm,
			    struct vm_area_struct *vma, unsigned long address,
			    pte_t *pte, pmd_t *pmd, unsigned int flags);
extern int split_huge_page(struct page *page);
extern void __split_huge_page_pmd(struct mm_struct *mm, pmd_t *pmd);
#define split_huge_page_pmd(__mm, __pmd) \
 do { \
 pmd_t *____pmd = (__pmd); \
 if (unlikely(pmd_trans_huge(*____pmd))) \
 __split_huge_page_pmd(__mm, ____pmd); \
 }