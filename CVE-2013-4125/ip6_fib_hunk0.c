
insert_above:
	/*
 * split since we don't have a common prefix anymore or
 * we have a less significant route.
 * we've to insert an intermediate node on the list
 * this new node will point to the one we need to create
 * and the current
 */

	pn = fn->parent;

	/* find 1st bit in difference between the 2 addrs.

 See comment in __ipv6_addr_diff: bit may be an invalid value,
 but if it is >= plen, the value is ignored in any case.
 */

	bit = __ipv6_addr_diff(addr, &key->addr, addrlen);

	/*
 * (intermediate)[in]
 * / \
 * (new leaf node)[ln] (old node)[fn]
 */
	if (plen > bit) {
		in = node_alloc();
		ln = node_alloc();

		if (!in || !ln) {
			if (in)
				node_free(in);
			if (ln)
				node_free(ln);
			return ERR_PTR(-ENOMEM);
		}

		/*
 * new intermediate node.
 * RTN_RTINFO will
 * be off since that an address that chooses one of
 * the branches would not match less specific routes
 * in the other branch
 */

		in->fn_bit = bit;

		in->parent = pn;
		in->leaf = fn->leaf;
		atomic_inc(&in->leaf->rt6i_ref);

		in->fn_sernum = sernum;

		/* update parent pointer */
		if (dir)
			pn->right = in;
		else
			pn->left  = in;

		ln->fn_bit = plen;

		ln->parent = in;
		fn->parent = in;

		ln->fn_sernum = sernum;

		if (addr_bit_set(addr, bit)) {
			in->right = ln;
			in->left  = fn;
		} else {
			in->left  = ln;
			in->right = fn;
		}
	}