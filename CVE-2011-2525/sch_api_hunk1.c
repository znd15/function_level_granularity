
static int qdisc_notify(struct net *net, struct sk_buff *oskb,
			struct nlmsghdr *n, u32 clid,
			struct Qdisc *old, struct Qdisc *new);
static int tclass_notify(struct net *net, struct sk_buff *oskb,
			 struct nlmsghdr *n, struct Qdisc *q,
			 unsigned long cl, int event);

/*

 Short review.
 -------------

 This file consists of two interrelated parts:

 1. queueing disciplines manager frontend.
 2. traffic classes manager frontend.

 Generally, queueing discipline ("qdisc") is a black box,
 which is able to enqueue packets and to dequeue them (when
 device is ready to send something) in order and at times
 determined by algorithm hidden in it.

 qdisc's are divided to two categories:
 - "queues", which have no internal structure visible from outside.
 - "schedulers", which split all the packets to "traffic classes",
 using "packet classifiers" (look at cls_api.c)

 In turn, classes may have child qdiscs (as rule, queues)
 attached to them etc. etc. etc.

 The goal of the routines in this file is to translate
 information supplied by user in the form of handles
 to more intelligible for kernel form, to make some sanity
 checks and part of work, which is common to all qdiscs
 and to provide rtnetlink notifications.

 All real intelligent work is done inside qdisc modules.



 Every discipline has two major routines: enqueue and dequeue.

 ---dequeue

 dequeue usually returns a skb to send. It is allowed to return NULL,
 but it does not mean that queue is empty, it just means that
 discipline does not want to send anything this time.
 Queue is really empty if q->q.qlen == 0.
 For complicated disciplines with multiple queues q->q is not
 real packet queue, but however q->q.qlen must be valid.

 ---enqueue

 enqueue returns 0, if packet was enqueued successfully.
 If packet (this one or another one) was dropped, it returns
 not zero error code.
 NET_XMIT_DROP - this packet dropped
 Expected action: do not backoff, but wait until queue will clear.
 NET_XMIT_CN - probably this packet enqueued, but another one dropped.
 Expected action: backoff or ignore
 NET_XMIT_POLICED - dropped by police.
 Expected action: backoff or error to real-time apps.

 Auxiliary routines:

 ---peek

 like dequeue but without removing a packet from the queue

 ---reset

 returns qdisc to initial state: purge all buffers, clear all
 timers, counters (except for statistics) etc.

 ---init

 initializes newly created qdisc.

 ---destroy

 destroys resources allocated by init and during lifetime of qdisc.

 ---change

 changes qdisc parameters.
 */

/* Protects list of registered TC modules. It is pure SMP lock. */
static DEFINE_RWLOCK(qdisc_mod_lock);


/************************************************
 * Queueing disciplines manipulation. *
 ************************************************/


/* The list of all installed queueing disciplines. */

static struct Qdisc_ops *qdisc_base;

/* Register/uregister queueing discipline */

int register_qdisc(struct Qdisc_ops *qops)
{
	struct Qdisc_ops *q, **qp;
	int rc = -EEXIST;

	write_lock(&qdisc_mod_lock);
	for (qp = &qdisc_base; (q = *qp) != NULL; qp = &q->next)
		if (!strcmp(qops->id, q->id))
			goto out;

	if (qops->enqueue == NULL)
		qops->enqueue = noop_qdisc_ops.enqueue;
	if (qops->peek == NULL) {
		if (qops->dequeue == NULL) {
			qops->peek = noop_qdisc_ops.peek;
		} else {
			rc = -EINVAL;
			goto out;
		}
	}
	if (qops->dequeue == NULL)
		qops->dequeue = noop_qdisc_ops.dequeue;

	qops->next = NULL;
	*qp = qops;
	rc = 0;
out:
	write_unlock(&qdisc_mod_lock);
	return rc;
}