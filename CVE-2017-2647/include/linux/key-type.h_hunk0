
struct key_type {
	/* name of the type */
	const char *name;

	/* default payload length for quota precalculation (optional)
 * - this can be used instead of calling key_payload_reserve(), that
 * function only needs to be called if the real datalen is different
 */
	size_t def_datalen;

	/* vet a description */
	int (*vet_description)(const char *description);

	/* Preparse the data blob from userspace that is to be the payload,
 * generating a proposed description and payload that will be handed to
 * the instantiate() and update() ops.
 */
	int (*preparse)(struct key_preparsed_payload *prep);

	/* Free a preparse data structure.
 */
	void (*free_preparse)(struct key_preparsed_payload *prep);

	/* instantiate a key of this type
 * - this method should call key_payload_reserve() to determine if the
 * user's quota will hold the payload
 */
	int (*instantiate)(struct key *key, struct key_preparsed_payload *prep);

	/* update a key of this type (optional)
 * - this method should call key_payload_reserve() to recalculate the
 * quota consumption
 * - the key must be locked against read when modifying
 */
	int (*update)(struct key *key, struct key_preparsed_payload *prep);

	/* Preparse the data supplied to ->match() (optional). The
 * data to be preparsed can be found in match_data->raw_data.
 * The lookup type can also be set by this function.
 */
	int (*match_preparse)(struct key_match_data *match_data);

	/* match a key against a description */
	int (*match)(const struct key *key,
		     const struct key_match_data *match_data);

	/* Free preparsed match data (optional). This should be supplied it
 * ->match_preparse() is supplied. */
	void (*match_free)(struct key_match_data *match_data);

	/* clear some of the data from a key on revokation (optional)
 * - the key's semaphore will be write-locked by the caller
 */
	void (*revoke)(struct key *key);

	/* clear the data from a key (optional) */
	void (*destroy)(struct key *key);

	/* describe a key */
	void (*describe)(const struct key *key, struct seq_file *p);

	/* read a key's data (optional)
 * - permission checks will be done by the caller
 * - the key's semaphore will be readlocked by the caller
 * - should return the amount of data that could be read, no matter how
 * much is copied into the buffer
 * - shouldn't do the copy if the buffer is NULL
 */
	long (*read)(const struct key *key, char __user *buffer, size_t buflen);

	/* handle request_key() for this type instead of invoking
 * /sbin/request-key (optional)
 * - key is the key to instantiate
 * - authkey is the authority to assume when instantiating this key
 * - op is the operation to be done, usually "create"
 * - the call must not return until the instantiation process has run
 * its course
 */
	request_key_actor_t request_key;

	/* internal fields */
	struct list_head	link;		/* link in types list */
	struct lock_class_key	lock_class;	/* key->sem lock class */
}